package main

import (
	"bytes"
	"fmt"
	"os"
	"strings"
	"text/template"

	"github.com/samuel/go-thrift"
	"github.com/samuel/go-thrift/parser"
)

// go_thrift_type_map = {
//     "byte": "TypeByte",
//     "bool": "TypeBool",
//     "i16": "TypeI16",
//     "i32": "TypeI32",
//     "i64": "TypeI64",
//     "double": "TypeDouble",
//     "string": "TypeString",
//     "binary": "TypeBinary",
// }

// go_write_methods = {
//     "byte": "WriteByte",
//     "bool": "WriteBool",
//     "i16": "WriteI16",
//     "i32": "WriteI32",
//     "i64": "WriteI64",
//     "double": "WriteDouble",
//     "string": "WriteString",
//     "binary": "WriteBytes",
// }

// go_read_methods = {
//     "byte": "ReadByte",
//     "bool": "ReadBool",
//     "i16": "ReadI16",
//     "i32": "ReadI32",
//     "i64": "ReadI64",
//     "double": "ReadDouble",
//     "string": "ReadString",
//     "binary": "ReadBytes",
// }

var (
	goTemplate *template.Template
)

func init() {
	funcMap := map[string]interface{}{
		"camelCase": camelCase,
		"mapType":   mapType,
	}

	goTemplate = template.New("go")
	goTemplate.Funcs(funcMap)
	goTemplate.Parse(`{{define "field"}}{{.Name|camelCase}} {{.Type|mapType}} ` + "`" + `thrift:"{{.Id}}{{if .Optional}}{{else}},required{{end}}"` + "`" + `{{end}}` +
		`{{range $name, $enum := .Enums}}
type {{$name|camelCase}} int32

var ({{range $vname, $vid := .Values}}
	{{$name|camelCase}}{{$vname|camelCase}} = {{$name|camelCase}}({{$vid.Value}}){{end}}
)

func (e {{$name|camelCase}}) String() string {
	switch e {{"{"}}{{range $vname, $vid := .Values}}
		case {{$name|camelCase}}{{$vname|camelCase}}: return "{{$name|camelCase}}{{$vname|camelCase}}"{{end}}
	}
	return fmt.Sprintf("Unknown value for {{$name|camelCase}}: %d", e)
}
{{end}}{{range $name, $field := .Structs}}
type {{$name|camelCase}} struct {{"{"}}{{range .Fields}}
	{{template "field" .}}{{end}}
}
{{end}}{{range $name, $field := .Exceptions}}
type {{$name|camelCase}} struct {{"{"}}{{range .Fields}}
	{{template "field" .}}{{end}}
}

func (e *{{$name|camelCase}}) Error() string {
	return fmt.Sprintf("{{$name|camelCase}}{TODO}")
}
{{end}}{{range $name, $svc := .Services}}
type {{$name|camelCase}} interface {{"{"}}{{range .Methods}}
	{{.Name|camelCase}}(...) ...{{end}}
}
{{end}}`)
}

func camelCase(st string) string {
	if strings.ToUpper(st) == st {
		st = strings.ToLower(st)
	}
	return thrift.CamelCase(st)
}

func mapType(typ *parser.Type) string {
	switch typ.Name {
	case "byte", "bool", "string":
		return typ.Name
	case "binary":
		return "[]byte"
	case "i16":
		return "int16"
	case "i32":
		return "int32"
	case "i64":
		return "int64"
	case "double":
		return "float64"
	case "list":
		return "[]" + mapType(typ.ValueType)
	case "map":
		keyType := mapType(typ.KeyType)
		if keyType == "[]byte" {
			// TODO: Log, warn, do something besides println!
			println("key type of []byte not supported for maps")
			keyType = "string"
		}
		return "map[" + keyType + "]" + mapType(typ.ValueType)
	}
	// TODO: Enums as non-pointers
	// TODO: References to types in includes
	return "*" + typ.Name
}

func main() {
	filename := os.Args[1]

	p := &parser.Parser{}
	th, err := p.ParseFile(filename)
	if e, ok := err.(*parser.ErrSyntaxError); ok {
		fmt.Printf("%s\n", e.Left)
		panic(err)
	} else if err != nil {
		panic(err)
	}

	out := &bytes.Buffer{}

	// Package docs and package name

	packageName := th.Namespaces["go"]
	if packageName == "" {
		packageName = th.Namespaces["perl"]
		if packageName == "" {
			packageName = th.Namespaces["py"]
			if packageName == "" {
				packageName = strings.Split(filename, ".")[0]
			} else {
				parts := strings.Split(packageName, ".")
				packageName = parts[len(parts)-1]
			}
		}
	}
	packageName = strings.ToLower(packageName)

	out.WriteString("// This file is automatically generated. Do not modify.\n\n")
	out.WriteString("package " + packageName + "\n")

	// Imports

	imports := []string{"fmt"}
	out.WriteString("\nimport (\n")
	for _, in := range imports {
		out.WriteString("\t\"" + in + "\"\n")
	}
	out.WriteString(")\n")

	err = goTemplate.Execute(out, th)
	if err != nil {
		panic(err)
	}

	fmt.Printf(out.String())
}
